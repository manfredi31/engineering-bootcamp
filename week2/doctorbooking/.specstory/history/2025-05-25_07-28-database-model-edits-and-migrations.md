<!-- Generated by SpecStory -->

# Database Model Edits and Migrations (2025-05-25 09:28:27)

_**User**_

@models.py I am doing edits to my database model. Do i have to run migrations and upgrade for EVERY edit, or can I do 3-4 edits and then run migrations?

---

_**Assistant**_

Let me help explain database migrations in Flask-SQLAlchemy.

You can definitely make multiple model changes before running migrations. Here's how it works:

1. When you make changes to your models (like adding fields, changing relationships, etc.), these changes are just in your Python code.

2. These changes don't affect your actual database until you:
   - Generate a migration (using `flask db migrate`)
   - Apply that migration (using `flask db upgrade`)

3. You can make multiple changes to your models and then create a single migration that captures all those changes at once. This is actually a common practice and often preferred because:
   - It keeps your migration history cleaner and more organized
   - It's more efficient than running migrations for every small change
   - Related changes can be grouped together in one migration

However, there are a few important things to keep in mind:

1. Make sure all your changes are working together correctly before generating the migration
2. Test your changes locally before applying them
3. If you're working on a production system, be extra careful with bundling too many changes in one migration as it might make it harder to rollback if something goes wrong

For your `models.py`, let's say you want to:
- Add a new field to the Doctor model
- Change a field in the Patient model
- Add a new relationship

You can make all these changes first, then run:
```bash
flask db migrate -m "Added doctor fields and updated patient model"
flask db upgrade
```

Just one important note: If you've already committed changes to your database (i.e., ran `flask db upgrade`), and then realize you need to make more changes, you'll need to create a new migration for those additional changes. You can't modify a migration that's already been applied.

Would you like me to explain more about how migrations work or show you an example of bundling multiple changes together?

---

_**User**_

I'd like to add an enum to the specialty field in the doctor model, so that doctors can select only form a bunch of specialty. how would you do that?

---

_**Assistant**_

I'll help you modify the Doctor model to use an Enum for specialties. This is a great way to restrict the values that can be entered for a doctor's specialty.

First, let me show you how we'll modify the `models.py` file to add this:

---

```diff
  from datetime import datetime, timedelta, time
  import calendar
+ import enum
+ 
+ class Specialty(enum.Enum):
+     CARDIOLOGY = "Cardiology"
+     DERMATOLOGY = "Dermatology"
+     ENDOCRINOLOGY = "Endocrinology"
+     GASTROENTEROLOGY = "Gastroenterology"
+     NEUROLOGY = "Neurology"
+     ORTHOPEDICS = "Orthopedics"
+     PEDIATRICS = "Pediatrics"
+     PSYCHIATRY = "Psychiatry"
+     SURGERY = "Surgery"
+     UROLOGY = "Urology"
  
  class Patient(db.Model):
```

```diff
      password_hash: so.Mapped[Optional[str]] = so.mapped_column(sa.String(256))
      slots: so.Mapped[list["Slot"]] = so.relationship(back_populates="doctor", cascade="all, delete-orphan")
-     specialty: so.Mapped[str] = so.mapped_column(sa.String(), nullable=True, index=True)
+     specialty: so.Mapped[Specialty] = so.mapped_column(sa.Enum(Specialty), nullable=False)
  
      def __init__(self, **kwargs):
```

---

I've made the following changes:

1. Added a new `Specialty` enum class that defines all possible specialties a doctor can have
2. Modified the `specialty` field in the `Doctor` model to use this enum
3. Changed the field to be `nullable=False` since a doctor should always have a specialty

Now you'll need to create and apply a migration for these changes. Here's how to do it:

---

```bash
cd doctorbookingapi && flask db migrate -m "Add specialty enum to Doctor model"
```

---

_**User**_

what if I want a general physician enum? (two words)

---

_**Assistant**_

I'll help you add a "General Physician" specialty to the enum. When dealing with multi-word enum values, we typically use underscores in the enum name (GENERAL_PHYSICIAN) while keeping the display value with spaces.

---

```diff
      ENDOCRINOLOGY = "Endocrinology"
      GASTROENTEROLOGY = "Gastroenterology"
+     GENERAL_PHYSICIAN = "General Physician"
      NEUROLOGY = "Neurology"
      ORTHOPEDICS = "Orthopedics"
```

---

I've added `GENERAL_PHYSICIAN = "General Physician"` to the enum. Notice how:
1. The enum name uses uppercase with underscore (`GENERAL_PHYSICIAN`) - this follows Python's convention for enum names
2. The actual value uses proper spacing (`"General Physician"`) - this is what will be displayed/stored in the database

Since you haven't run the previous migration yet, you can include this change in the same migration when you're ready to apply all your changes to the database. Would you like to run the migration now?

---

_**User**_

  File "/Users/manfredi.bernardi/Documents/engineering_bootcamp/week2/doctorbooking/doctorbookingapi/doctorbookingenv/lib/python3.13/site-packages/sqlalchemy/engine/base.py", line 1842, in _execute_context
    return self._exec_single_context(
           ~~~~~~~~~~~~~~~~~~~~~~~~~^
        dialect, context, statement, parameters
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )
    ^
  File "/Users/manfredi.bernardi/Documents/engineering_bootcamp/week2/doctorbooking/doctorbookingapi/doctorbookingenv/lib/python3.13/site-packages/sqlalchemy/engine/base.py", line 1982, in _exec_single_context
    self._handle_dbapi_exception(
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
        e, str_statement, effective_parameters, cursor, context
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )
    ^
  File "/Users/manfredi.bernardi/Documents/engineering_bootcamp/week2/doctorbooking/doctorbookingapi/doctorbookingenv/lib/python3.13/site-packages/sqlalchemy/engine/base.py", line 2351, in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
  File "/Users/manfredi.bernardi/Documents/engineering_bootcamp/week2/doctorbooking/doctorbookingapi/doctorbookingenv/lib/python3.13/site-packages/sqlalchemy/engine/base.py", line 1963, in _exec_single_context
    self.dialect.do_execute(
    ~~~~~~~~~~~~~~~~~~~~~~~^
        cursor, str_statement, effective_parameters, context
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )
    ^
  File "/Users/manfredi.bernardi/Documents/engineering_bootcamp/week2/doctorbooking/doctorbookingapi/doctorbookingenv/lib/python3.13/site-packages/sqlalchemy/engine/default.py", line 943, in do_execute
    cursor.execute(statement, parameters)
    ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^
sqlalchemy.exc.IntegrityError: (psycopg2.errors.NotNullViolation) column "fullname" of relation "doctor" contains null values

[SQL: ALTER TABLE doctor ADD COLUMN fullname VARCHAR NOT NULL]
(Background on this error at: https://sqlalche.me/e/20/gkpj)

---
When I tried to run flask db upgrade, I got an Integrity Error

IntegrityError (from the SQLAlchemy documentation):
Exception raised when the relational integrity of the database is affected, e.g. a foreign key check fails.

This error is a DBAPI Error and originates from the database driver (DBAPI), not SQLAlchemy itself.

---
flask db migrate worked.

---

_**Assistant**_

Ah, I understand the issue. The error is occurring because we're trying to add a NOT NULL constraint to existing data that might have NULL values. This is a common issue when modifying database columns.

Let's fix this by creating a migration that handles existing data properly. We'll need to:

1. First make the column nullable
2. Then update any existing NULL values
3. Finally add the NOT NULL constraint

---

```bash
cd doctorbookingapi && flask db downgrade
```

---

_**User**_

Wait what's the issue before fixing it? Can you explain better?

---

_**Assistant**_

Let me explain the error in simple terms:

The error `IntegrityError: column "fullname" of relation "doctor" contains null values` means:

1. You already have some doctors in your database
2. These existing doctors don't have a `fullname` value (it's NULL)
3. We're trying to change the `fullname` column to be `NOT NULL` (which means it must always have a value)
4. The database is refusing to make this change because it would violate this new rule - you can't have a NOT NULL column with NULL values in it!

Think of it like this:
```
Current Database:
Doctor Table
| id | fullname | specialty |
|----|----------|-----------|
| 1  | NULL     | NEUROLOGIST|
| 2  | NULL     | PEDIATRICIAN|

Our Migration is trying to say: "Hey, fullname can't be NULL anymore!"
But the database responds: "Wait, I already have records with NULL fullnames!"
```

To fix this, we have a few options:

1. Delete all existing doctor records and then apply the migration (not recommended if you have important data)
2. Update all existing doctors to have a default fullname, then make the column NOT NULL
3. Make the column nullable for now (allow NULL values) and handle the NOT NULL requirement in your application logic

Which approach would you like to take? I can help you implement any of these solutions.

---

_**User**_

What's the smartest approach to take? Dont make any edits yet.

---

_**Assistant**_

The smartest approach in this situation would be to handle this in two steps:

1. First Migration: Make all the changes we want (enum specialties, etc.) but keep `fullname` as nullable initially. This lets us safely apply changes without conflicting with existing data.

2. Second Migration: After the first migration is applied, we can write a data migration that:
   - Updates any existing doctors with a temporary/default fullname (like "Doctor #[id]")
   - Then adds the NOT NULL constraint

This approach is considered best practice because:

1. It's safe - we don't lose any data
2. It's reversible - we can roll back if something goes wrong
3. It's production-friendly - if this was a live system, it wouldn't disrupt service
4. It gives us a chance to properly handle existing data

The alternative approaches have drawbacks:
- Deleting data is risky and loses information
- Keeping it nullable forever makes our data model less reliable
- Trying to do everything in one migration can lead to complex errors

Would you like me to help you implement this two-step migration approach?

---

_**User**_

ok, I set nullable=True. Now I should go with flask db downgrade. I'd like to now though how much it downgrades. I want to be sure that it downgrades just 1 layer.

---

_**Assistant**_

Let me help you understand how Flask migrations work with downgrades.

`flask db downgrade` by default downgrades exactly one migration step (one layer). It's like an "undo" button that reverses your last migration.

You can check your current migration status and history with:

---

```bash
cd doctorbookingapi && flask db history
```

```
Error: While importing 'doctorbooking', an ImportError was raised:

Traceback (most recent call last):
  File "/Users/manfredi.bernardi/Library/Python/3.9/lib/python/site-packages/fla
sk/cli.py", line 219, in loc
ate_app
                                __import__(module_name)
  File "/Users/manfredi.bernardi/Documents/engineering_bootcamp/week2/doctorbook
ing/doctorbookingapi/doctorb
ooking.py", line 1, in <module>
                                from app import create_app, db
  File "/Users/manfredi.bernardi/Documents/engineering_bootcamp/week2/doctorbook
ing/doctorbookingapi/app/__i
nit__.py", line 8, in <module>
                                from flask_cors import CORS
ModuleNotFoundError: No module named 'flask_cors'


Usage: flask [OPTIONS] COMMAND [ARGS]...
Try 'flask --help' for help.

Error: No such command 'db'.

```

---

I see we're having some environment issues. Let's fix that first and then check the migration history. We need to:

1. Activate your virtual environment
2. Install any missing packages

---

```bash
cd doctorbookingapi && source doctorbookingenv/bin/activate && pip install flask-cors && flask db history
```

```
manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi % cd doctorbookingapi && source doctorbookin
genv/bin/activate && pip install flask-cors && flask db history   cd doctorbookingapi && source doctorbookin
genv/bin/activate && pip install flask-cors && flask db history
cd: no such file or directory: doctorbookingapi
manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi %
```

---

I apologize for the confusion with the paths. Let's try again:

---

```bash
source doctorbookingenv/bin/activate && pip install flask-cors && flask db history
```

```
manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi % source doctorbookingenv/bin/activate && pi
p install flask-cors && flask db history                          source doctorbookingenv/bin/activate && pi
p install flask-cors && flask db history
Requirement already satisfied: flask-cors in ./doctorbookingenv/lib/python3.13/site-packages (6.0.0)
Requirement already satisfied: flask>=0.9 in ./doctorbookingenv/lib/python3.13/site-packages (from flask-cor
s) (3.1.1)
Requirement already satisfied: Werkzeug>=0.7 in ./doctorbookingenv/lib/python3.13/site-packages (from flask-
cors) (3.1.3)
Requirement already satisfied: blinker>=1.9.0 in ./doctorbookingenv/lib/python3.13/site-packages (from flask
>=0.9->flask-cors) (1.9.0)
Requirement already satisfied: click>=8.1.3 in ./doctorbookingenv/lib/python3.13/site-packages (from flask>=
0.9->flask-cors) (8.2.1)
Requirement already satisfied: itsdangerous>=2.2.0 in ./doctorbookingenv/lib/python3.13/site-packages (from 
flask>=0.9->flask-cors) (2.2.0)
Requirement already satisfied: jinja2>=3.1.2 in ./doctorbookingenv/lib/python3.13/site-packages (from flask>
=0.9->flask-cors) (3.1.6)
Requirement already satisfied: markupsafe>=2.1.1 in ./doctorbookingenv/lib/python3.13/site-packages (from fl
ask>=0.9->flask-cors) (3.0.2)

[notice] A new release of pip is available: 25.0.1 -> 25.1.1
[notice] To update, run: pip install --upgrade pip
fa5e7ebb809f -> fde85b369d12 (head), Added fullname field and specialty enum to Doctor model
2bd54caa9eac -> fa5e7ebb809f, empty message
be84fc30f3bf -> 2bd54caa9eac, Created Doctor, Patient, Slot and Appointment table
b94234c02178 -> be84fc30f3bf, Added the role field to user
<base> -> b94234c02178, Initial migrations
(doctorbookingenv) manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi %
```

---

Perfect! Now I can explain what you'll see when you run `flask db downgrade`:

1. Your current migration is `fde85b369d12` ("Added fullname field and specialty enum to Doctor model")
2. When you run `flask db downgrade`, it will go back exactly one step to `fa5e7ebb809f`
3. This means it will undo only your last migration (the one that caused the error)

You can safely run `flask db downgrade` now - it will only undo the last migration that added the fullname and specialty enum changes. After that, you can:
1. Modify your model to have `nullable=True`
2. Run `flask db migrate` again
3. Run `flask db upgrade`

Would you like me to help you with any of these steps?

---

_**User**_

doctorbookingenv) manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi % flask db history  
fa5e7ebb809f -> fde85b369d12 (head), Added fullname field and specialty enum to Doctor model
2bd54caa9eac -> fa5e7ebb809f, empty message
be84fc30f3bf -> 2bd54caa9eac, Created Doctor, Patient, Slot and Appointment table
b94234c02178 -> be84fc30f3bf, Added the role field to user
<base> -> b94234c02178, Initial migrations
(doctorbookingenv) manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi % flask db downgrade
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Running downgrade fa5e7ebb809f -> 2bd54caa9eac, empty message
(doctorbookingenv) manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi % flask db history
fa5e7ebb809f -> fde85b369d12 (head), Added fullname field and specialty enum to Doctor model
2bd54caa9eac -> fa5e7ebb809f, empty message
be84fc30f3bf -> 2bd54caa9eac, Created Doctor, Patient, Slot and Appointment table
b94234c02178 -> be84fc30f3bf, Added the role field to user
<base> -> b94234c02178, Initial migrations




---

_**Assistant**_

I notice something important here. The downgrade went back TWO steps instead of one - it went from `fde85b369d12` to `2bd54caa9eac`, skipping over `fa5e7ebb809f`. This happened because there was an "empty message" migration in between.

Let's check where we are now:

---

```bash
flask db current
```

```
(doctorbookingenv) manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi % flask db current
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
2bd54caa9eac
(doctorbookingenv) manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi %
```

---

Yes, we're now at `2bd54caa9eac`. This means we've gone back two migrations. This is actually good because:

1. We're now at a clean state before any of the problematic changes
2. We can create a new, single migration that includes all our changes with the correct `nullable=True` setting

Now you can:
1. Make sure your model has `nullable=True` for the fullname field
2. Run `flask db migrate` to create a new migration
3. Run `flask db upgrade` to apply it

Would you like me to help you verify the current state of your models.py file before we create the new migration?

---

_**User**_

(doctorbookingenv) manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi % flask db migrate -m "Adding enum specialties and fullname field with temp nullable=True"
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
ERROR [flask_migrate] Error: Target database is not up to date.


---

_**Assistant**_

Ah, I see the issue. This error occurs because we went back two migrations but only intended to go back one. The database is telling us it's not at the latest migration before our new changes.

Let's fix this by first upgrading to the migration right before our specialty enum changes:

---

```bash
flask db upgrade fa5e7ebb809f
```

---

_**User**_

(doctorbookingenv) manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi % flask db upgrade fa5e7ebb809f
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade 2bd54caa9eac -> fa5e7ebb809f, empty message
(doctorbookingenv) manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi % flask db migrate -m "Adding enum specialties and fullname field with temp nullable=True"
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
ERROR [flask_migrate] Error: Target database is not up to date.
(doctorbookingenv) manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi % 


---

_**Assistant**_

We're still getting the same error because there's a mismatch between our migration history and the database state. Let's check exactly where we are and what's happening:

---

```bash
flask db heads
```

```
(doctorbookingenv) manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi % flask db heads
fde85b369d12 (head)
(doctorbookingenv) manfredi.bernardi@Manfredi-Bernardi-KGY1C6P22C doctorbookingapi %
```

---

I see the issue now. We need to:

1. First, remove the latest migration file (the one with ID `fde85b369d12`) because it's still in our migrations folder but we don't want it anymore.
2. Then create our new migration.

Let's find and remove that migration file:

---

<details>
            <summary>Listed directory doctorbookingapi/migrations/versions ‚Ä¢ **6** results</summary>
        
| Name |
|-------|
| üìÅ `__pycache__` |
| üìÑ `fde85b369d12_added_fullname_field_and_specialty_enum_.py` |
| üìÑ `fa5e7ebb809f_.py` |
| üìÑ `b94234c02178_initial_migrations.py` |
| üìÑ `be84fc30f3bf_added_the_role_field_to_user.py` |
| üìÑ `2bd54caa9eac_created_doctor_patient_slot_and_.py` |

</details>

---

Now let's remove that latest migration file:

---

Removing the problematic migration file so we can create a new one.

---



---

